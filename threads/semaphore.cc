#include "synch.hh"
#include "system.hh"

/// Initialize a semaphore, so that it can be used for synchronization.
///
/// * `debugName` is an arbitrary name, useful for debugging.
/// * `initialValue` is the initial value of the semaphore.
Semaphore::Semaphore(const char *debugName, int initialValue) {
    name  = debugName;
    value = initialValue;
    queue = new List<Thread *>;
}

/// De-allocate semaphore, when no longer needed.
///
/// Assume no one is still waiting on the semaphore!
Semaphore::~Semaphore() {
    delete queue;
}

const char *
Semaphore::GetName() const {
    return name;
}

/// Wait until semaphore `value > 0`, then decrement.
///
/// Checking the value and decrementing must be done atomically, so we need
/// to disable interrupts before checking the value.
///
/// Note that `Thread::Sleep` assumes that interrupts are disabled when it is
/// called.
void
Semaphore::P() {
    IntStatus oldLevel = interrupt->SetLevel(INT_OFF); // Disable interrupts.
    DEBUG('s', "Thread `%s` doing " BOLD RED "P ", currentThread->GetName());
    DEBUG_CONT('s', "on semaphore `%s` with value %d.\n", name, value);

    while (value == 0) {  // Semaphore not available.
        queue->Append(currentThread);  // So go to sleep.
        currentThread->Sleep();
    }
    value--;  // Semaphore available, consume its value.

    interrupt->SetLevel(oldLevel);  // Re-enable interrupts.
}

/// Increment semaphore value, waking up a waiter if necessary.
///
/// As with `P`, this operation must be atomic, so we need to disable
/// interrupts.  `Scheduler::ReadyToRun` assumes that threads are disabled
/// when it is called.
void
Semaphore::V() {
    IntStatus oldLevel = interrupt->SetLevel(INT_OFF);
    DEBUG('s', "Thread `%s` doing " BOLD GREEN "V ", currentThread->GetName());
    DEBUG_CONT('s', "on semaphore `%s` with value %d.\n", name, value);

    Thread *thread = queue->Pop();
    if (thread)
        // Make thread ready, consuming the `V` immediately.
        scheduler->ReadyToRun(thread);
    value++;

    interrupt->SetLevel(oldLevel);
}
